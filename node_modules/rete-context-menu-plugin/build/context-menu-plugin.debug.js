/*!
* rete-context-menu-plugin v0.3.3 
* (c) 2019  
* Released under the ISC license.
*/
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('lodash'), require('vue')) :
    typeof define === 'function' && define.amd ? define(['lodash', 'vue'], factory) :
    (global.ContextMenuPlugin = factory(global._,global.Vue));
}(this, (function (lodash,Vue) { 'use strict';

    function ___$insertStyle(css) {
      if (!css) {
        return;
      }
      if (typeof window === 'undefined') {
        return;
      }

      var style = document.createElement('style');

      style.setAttribute('type', 'text/css');
      style.innerHTML = css;
      document.head.appendChild(style);

      return css;
    }

    Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;

    function deepCopy(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    async function createNode(component, { data = {}, meta = {}, x = 0, y = 0 }) {
        const node = await component.createNode(deepCopy(data));

        node.meta = deepCopy(meta);
        node.position[0] = x;
        node.position[1] = y;

        return node;
    }

    function traverse(items, callback, path = []) {
        if (typeof items !== 'object') return;

        Object.keys(items).map(key => {
            if (typeof items[key] === 'function') callback(key, items[key], path);else traverse(items[key], callback, [...path, key]);
        });
    }

    function fitViewport([x, y], element) {
        return [Math.min(x, window.innerWidth - element.clientWidth), Math.min(y, window.innerHeight - element.clientHeight)];
    }

    var hideMixin = (hideMethod => {
        return {
            props: { delay: { type: Number, required: true } },
            data() {
                return {
                    timeoutHide: () => {}
                };
            },
            methods: {
                cancelHide() {
                    const hide = this.timeoutHide;

                    if (hide && hide.cancel) this.timeoutHide.cancel();
                }
            },
            mounted() {
                this.timeoutHide = lodash.debounce(this[hideMethod], this.delay);
            }
        };
    });

    //

    var script = {
      name: 'Item',
      mixins: [hideMixin('hideSubitems')],
      props: { item: Object, args: Object },
      data() {
        return {
          visibleSubitems: false
        };
      },
      computed: {
        hasSubitems() {
          return this.item.subitems;
        }
      },
      methods: {
        showSubitems() {
          this.visibleSubitems = true;
          this.cancelHide();
        },
        hideSubitems() {
          this.visibleSubitems = false;
        },
        onClick(e) {
          e.stopPropagation();

          if (this.item.onClick) this.item.onClick(this.args);
          this.$root.$emit('hide');
        }
      }
    };

    /* script */
    const __vue_script__ = script;

    /* template */
    var __vue_render__ = function () {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _c("div", {
        staticClass: "item",
        class: { hasSubitems: _vm.hasSubitems },
        on: {
          click: function ($event) {
            _vm.onClick($event);
          },
          mouseover: function ($event) {
            _vm.showSubitems();
          },
          mouseleave: function ($event) {
            _vm.timeoutHide();
          }
        }
      }, [_vm._v(_vm._s(_vm.item.title)), _c("div", {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: _vm.hasSubitems && this.visibleSubitems,
          expression: "hasSubitems && this.visibleSubitems"
        }],
        staticClass: "subitems"
      }, _vm._l(_vm.item.subitems, function (subitem) {
        return _c("Item", {
          key: subitem.title,
          attrs: { item: subitem, args: _vm.args, delay: _vm.delay }
        });
      }))]);
    };
    var __vue_staticRenderFns__ = [];
    __vue_render__._withStripped = true;

    /* style */
    const __vue_inject_styles__ = function (inject) {
      if (!inject) return;
      inject("data-v-00ad887c_0", { source: "\n@charset \"UTF-8\";\n.item[data-v-00ad887c], .item .subitems .subitem[data-v-00ad887c] {\n  color: #fff;\n  padding: 4px;\n  border-bottom: 1px solid rgba(69, 103, 255, 0.8);\n  background-color: rgba(110, 136, 255, 0.8);\n  cursor: pointer;\n  width: 100%;\n  position: relative;\n}\n.item[data-v-00ad887c]:first-child, .item .subitems .subitem[data-v-00ad887c]:first-child {\n    border-top-left-radius: 5px;\n    border-top-right-radius: 5px;\n}\n.item[data-v-00ad887c]:last-child, .item .subitems .subitem[data-v-00ad887c]:last-child {\n    border-bottom-left-radius: 5px;\n    border-bottom-right-radius: 5px;\n}\n.item[data-v-00ad887c]:hover, .item .subitems .subitem[data-v-00ad887c]:hover {\n    background-color: rgba(130, 153, 255, 0.8);\n}\n.hasSubitems.item[data-v-00ad887c]:after, .item .subitems .hasSubitems.subitem[data-v-00ad887c]:after {\n  content: '►';\n  position: absolute;\n  opacity: 0.6;\n  right: 5px;\n  top: 5px;\n}\n.item .subitems[data-v-00ad887c], .item .subitems .subitem .subitems[data-v-00ad887c] {\n  position: absolute;\n  top: 0;\n  left: 100%;\n  width: 120px;\n}\n\n/*# sourceMappingURL=Item.vue.map */", map: { "version": 3, "sources": ["Item.vue", "/media/ni55an/1902898F7AF8DF70102/Workflow/retejs/context-menu-plugin/src/Item.vue"], "names": [], "mappings": ";AAAA,iBAAiB;ACyDjB;EDvDE,YAAY;EACZ,aAAa;EACb,iDAAiD;EACjD,2CAA2C;EAC3C,gBAAgB;EAChB,YAAY;EACZ,mBAAmB;CAAE;ACiDvB;ID/CI,4BAA4B;IAC5B,6BAA6B;CAAE;AC8CnC;ID5CI,+BAA+B;IAC/B,gCAAgC;CAAE;AC2CtC;IDzCI,2CAA2C;CAAE;AC2CjD;EACA,aAAA;EACA,mBAAA;EACA,aAAA;EACA,WAAA;EACA,SAAA;CAAA;AAPA;EASA,mBAAA;EACA,OAAA;EACA,WAAA;EACA,aAAA;CAEA;;ADxCA,oCAAoC", "file": "Item.vue", "sourcesContent": ["@charset \"UTF-8\";\n.item, .item .subitems .subitem {\n  color: #fff;\n  padding: 4px;\n  border-bottom: 1px solid rgba(69, 103, 255, 0.8);\n  background-color: rgba(110, 136, 255, 0.8);\n  cursor: pointer;\n  width: 100%;\n  position: relative; }\n  .item:first-child, .item .subitems .subitem:first-child {\n    border-top-left-radius: 5px;\n    border-top-right-radius: 5px; }\n  .item:last-child, .item .subitems .subitem:last-child {\n    border-bottom-left-radius: 5px;\n    border-bottom-right-radius: 5px; }\n  .item:hover, .item .subitems .subitem:hover {\n    background-color: rgba(130, 153, 255, 0.8); }\n\n.hasSubitems.item:after, .item .subitems .hasSubitems.subitem:after {\n  content: '►';\n  position: absolute;\n  opacity: 0.6;\n  right: 5px;\n  top: 5px; }\n\n.item .subitems, .item .subitems .subitem .subitems {\n  position: absolute;\n  top: 0;\n  left: 100%;\n  width: 120px; }\n\n/*# sourceMappingURL=Item.vue.map */", null] }, media: undefined });
    };
    /* scoped */
    const __vue_scope_id__ = "data-v-00ad887c";
    /* module identifier */
    const __vue_module_identifier__ = undefined;
    /* functional template */
    const __vue_is_functional_template__ = false;
    /* component normalizer */
    function __vue_normalize__(template, style, script$$1, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
      const component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "/media/ni55an/1902898F7AF8DF70102/Workflow/retejs/context-menu-plugin/src/Item.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
      }

      component._scopeId = scope;

      {
        let hook;
        if (style) {
          hook = function (context) {
            style.call(this, createInjector(context));
          };
        }

        if (hook !== undefined) {
          if (component.functional) {
            // register for functional component in vue file
            const originalRender = component.render;
            component.render = function renderWithStyleInjection(h, context) {
              hook.call(context);
              return originalRender(h, context);
            };
          } else {
            // inject component registration as beforeCreate hook
            const existing = component.beforeCreate;
            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
        }
      }

      return component;
    }
    /* style inject */
    function __vue_create_injector__() {
      const head = document.head || document.getElementsByTagName('head')[0];
      const styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
      const isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

      return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

        const group = isOldIE ? css.media || 'default' : id;
        const style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
          let code = css.source;
          let index = style.ids.length;

          style.ids.push(id);

          if (isOldIE) {
            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
          }

          if (!style.element) {
            const el = style.element = document.createElement('style');
            el.type = 'text/css';

            if (css.media) el.setAttribute('media', css.media);
            if (isOldIE) {
              el.setAttribute('data-group', group);
              el.setAttribute('data-next-index', '0');
            }

            head.appendChild(el);
          }

          if (isOldIE) {
            index = parseInt(style.element.getAttribute('data-next-index'));
            style.element.setAttribute('data-next-index', index + 1);
          }

          if (style.element.styleSheet) {
            style.parts.push(code);
            style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
          } else {
            const textNode = document.createTextNode(code);
            const nodes = style.element.childNodes;
            if (nodes[index]) style.element.removeChild(nodes[index]);
            if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
          }
        }
      };
    }
    /* style inject SSR */

    var Item = __vue_normalize__({ render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, __vue_create_injector__, undefined);

    //
    //
    //
    //
    //

    var script$1 = {
      props: ['search'],
      data() {
        return {
          value: ''
        };
      },
      watch: {
        value() {
          this.$emit('search', this.value);
        }
      }
    };

    /* script */
    const __vue_script__$1 = script$1;

    /* template */
    var __vue_render__$1 = function () {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _c("div", { staticClass: "search" }, [_c("input", {
        directives: [{
          name: "model",
          rawName: "v-model",
          value: _vm.value,
          expression: "value"
        }],
        domProps: { value: _vm.value },
        on: {
          input: function ($event) {
            if ($event.target.composing) {
              return;
            }
            _vm.value = $event.target.value;
          }
        }
      })]);
    };
    var __vue_staticRenderFns__$1 = [];
    __vue_render__$1._withStripped = true;

    /* style */
    const __vue_inject_styles__$1 = function (inject) {
      if (!inject) return;
      inject("data-v-6d356512_0", { source: "\n.search input[data-v-6d356512] {\n  color: white;\n  padding: 1px 8px;\n  border: 1px solid white;\n  border-radius: 10px;\n  font-size: 16px;\n  font-family: serif;\n  width: 100%;\n  box-sizing: border-box;\n  background: transparent;\n}\n\n/*# sourceMappingURL=Search.vue.map */", map: { "version": 3, "sources": ["/media/ni55an/1902898F7AF8DF70102/Workflow/retejs/context-menu-plugin/src/Search.vue", "Search.vue"], "names": [], "mappings": ";AAuBA;EAEA,aAAA;EACA,iBAAA;EACA,wBAAA;EACA,oBAAA;EACA,gBAAA;EACA,mBAAA;EACA,YAAA;EACA,uBAAA;EACA,wBAAA;CAAA;;ACtBA,sCAAsC", "file": "Search.vue", "sourcesContent": [null, ".search input {\n  color: white;\n  padding: 1px 8px;\n  border: 1px solid white;\n  border-radius: 10px;\n  font-size: 16px;\n  font-family: serif;\n  width: 100%;\n  box-sizing: border-box;\n  background: transparent; }\n\n/*# sourceMappingURL=Search.vue.map */"] }, media: undefined });
    };
    /* scoped */
    const __vue_scope_id__$1 = "data-v-6d356512";
    /* module identifier */
    const __vue_module_identifier__$1 = undefined;
    /* functional template */
    const __vue_is_functional_template__$1 = false;
    /* component normalizer */
    function __vue_normalize__$1(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
      const component = (typeof script === 'function' ? script.options : script) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "/media/ni55an/1902898F7AF8DF70102/Workflow/retejs/context-menu-plugin/src/Search.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
      }

      component._scopeId = scope;

      {
        let hook;
        if (style) {
          hook = function (context) {
            style.call(this, createInjector(context));
          };
        }

        if (hook !== undefined) {
          if (component.functional) {
            // register for functional component in vue file
            const originalRender = component.render;
            component.render = function renderWithStyleInjection(h, context) {
              hook.call(context);
              return originalRender(h, context);
            };
          } else {
            // inject component registration as beforeCreate hook
            const existing = component.beforeCreate;
            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
        }
      }

      return component;
    }
    /* style inject */
    function __vue_create_injector__$1() {
      const head = document.head || document.getElementsByTagName('head')[0];
      const styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
      const isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

      return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

        const group = isOldIE ? css.media || 'default' : id;
        const style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
          let code = css.source;
          let index = style.ids.length;

          style.ids.push(id);

          if (isOldIE) {
            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
          }

          if (!style.element) {
            const el = style.element = document.createElement('style');
            el.type = 'text/css';

            if (css.media) el.setAttribute('media', css.media);
            if (isOldIE) {
              el.setAttribute('data-group', group);
              el.setAttribute('data-next-index', '0');
            }

            head.appendChild(el);
          }

          if (isOldIE) {
            index = parseInt(style.element.getAttribute('data-next-index'));
            style.element.setAttribute('data-next-index', index + 1);
          }

          if (style.element.styleSheet) {
            style.parts.push(code);
            style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
          } else {
            const textNode = document.createTextNode(code);
            const nodes = style.element.childNodes;
            if (nodes[index]) style.element.removeChild(nodes[index]);
            if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
          }
        }
      };
    }
    /* style inject SSR */

    var Search = __vue_normalize__$1({ render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 }, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, __vue_create_injector__$1, undefined);

    //

    var script$2 = {
      props: { searchBar: Boolean },
      mixins: [hideMixin('hide')],
      data() {
        return {
          x: 0,
          y: 0,
          visible: false,
          args: {},
          filter: '',
          items: []
        };
      },
      computed: {
        style() {
          return {
            top: this.y + 'px',
            left: this.x + 'px'
          };
        },
        filtered() {
          if (!this.filter) return this.items;

          return this.extractLeafs(this.items).filter(i => {
            return i.title.toLowerCase().includes(this.filter.toLowerCase());
          });
        }
      },
      methods: {
        extractLeafs(items) {
          if (!items) return [];
          let leafs = [];
          items.map(item => {
            if (!item.subitems) leafs.push(item);

            leafs.push(...this.extractLeafs(item.subitems));
          });

          return leafs;
        },
        onSearch(e) {
          this.filter = e;
        },
        show(x, y, args = {}) {
          this.visible = true;
          this.x = x;
          this.y = y;
          this.args = args;

          this.cancelHide();
        },
        hide() {
          this.visible = false;
        },
        additem(title, onClick, path = []) {
          let items = this.items;

          if (!(path && (typeof path[Symbol.iterator] === 'function' || Array.isArray(path)))) {
            throw new TypeError('Expected path to be iterable, got ' + _inspect(path));
          }

          for (let level of path) {
            let exist = items.find(i => {
              return i.title === level;
            });

            if (!exist) {
              exist = { title: level, subitems: [] };
              items.push(exist);
            }

            items = exist.subitems || (exist.subitems = []);
          }

          items.push({ title, onClick });
        }
      },
      updated() {
        if (this.$refs.menu) {
          [this.x, this.y] = fitViewport([this.x, this.y], this.$refs.menu);
        }
      },
      mounted() {
        this.$root.$on('show', this.show);
        this.$root.$on('hide', this.hide);
        this.$root.$on('additem', this.additem);
      },
      components: {
        Item,
        Search
      }
    };

    function _inspect(input, depth) {
      const maxDepth = 4;
      const maxKeys = 15;

      if (depth === undefined) {
        depth = 0;
      }

      depth += 1;

      if (input === null) {
        return 'null';
      } else if (input === undefined) {
        return 'void';
      } else if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean') {
        return typeof input;
      } else if (Array.isArray(input)) {
        if (input.length > 0) {
          if (depth > maxDepth) return '[...]';

          const first = _inspect(input[0], depth);

          if (input.every(item => _inspect(item, depth) === first)) {
            return first.trim() + '[]';
          } else {
            return '[' + input.slice(0, maxKeys).map(item => _inspect(item, depth)).join(', ') + (input.length >= maxKeys ? ', ...' : '') + ']';
          }
        } else {
          return 'Array';
        }
      } else {
        const keys = Object.keys(input);

        if (!keys.length) {
          if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
            return input.constructor.name;
          } else {
            return 'Object';
          }
        }

        if (depth > maxDepth) return '{...}';
        const indent = '  '.repeat(depth - 1);
        let entries = keys.slice(0, maxKeys).map(key => {
          return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + ': ' + _inspect(input[key], depth) + ';';
        }).join('\n  ' + indent);

        if (keys.length >= maxKeys) {
          entries += '\n  ' + indent + '...';
        }

        if (input.constructor && input.constructor.name && input.constructor.name !== 'Object') {
          return input.constructor.name + ' {\n  ' + indent + entries + '\n' + indent + '}';
        } else {
          return '{\n  ' + indent + entries + '\n' + indent + '}';
        }
      }
    }

    /* script */
    const __vue_script__$2 = script$2;

    /* template */
    var __vue_render__$2 = function () {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _vm.visible ? _c("div", {
        ref: "menu",
        staticClass: "context-menu",
        style: _vm.style,
        on: {
          mouseleave: function ($event) {
            _vm.timeoutHide();
          },
          mouseover: function ($event) {
            _vm.cancelHide();
          },
          contextmenu: function ($event) {
            $event.preventDefault();
          }
        }
      }, [_vm.searchBar ? _c("Search", { on: { search: _vm.onSearch } }) : _vm._e(), _vm._l(_vm.filtered, function (item) {
        return _c("Item", {
          key: item.title,
          attrs: { item: item, args: _vm.args, delay: _vm.delay / 2 }
        });
      })], 2) : _vm._e();
    };
    var __vue_staticRenderFns__$2 = [];
    __vue_render__$2._withStripped = true;

    /* style */
    const __vue_inject_styles__$2 = function (inject) {
      if (!inject) return;
      inject("data-v-8dfbff8c_0", { source: "\n.item[data-v-8dfbff8c], .context-menu .search[data-v-8dfbff8c] {\n  color: #fff;\n  padding: 4px;\n  border-bottom: 1px solid rgba(69, 103, 255, 0.8);\n  background-color: rgba(110, 136, 255, 0.8);\n  cursor: pointer;\n  width: 100%;\n  position: relative;\n}\n.item[data-v-8dfbff8c]:first-child, .context-menu .search[data-v-8dfbff8c]:first-child {\n    border-top-left-radius: 5px;\n    border-top-right-radius: 5px;\n}\n.item[data-v-8dfbff8c]:last-child, .context-menu .search[data-v-8dfbff8c]:last-child {\n    border-bottom-left-radius: 5px;\n    border-bottom-right-radius: 5px;\n}\n.item[data-v-8dfbff8c]:hover, .context-menu .search[data-v-8dfbff8c]:hover {\n    background-color: rgba(130, 153, 255, 0.8);\n}\n.context-menu[data-v-8dfbff8c] {\n  left: 0;\n  top: 0;\n  position: fixed;\n  padding: 10px;\n  width: 120px;\n  margin-top: -20px;\n  margin-left: -60px;\n}\n\n/*# sourceMappingURL=Menu.vue.map */", map: { "version": 3, "sources": ["Menu.vue", "/media/ni55an/1902898F7AF8DF70102/Workflow/retejs/context-menu-plugin/src/Menu.vue"], "names": [], "mappings": ";AAAA;EACE,YAAY;EACZ,aAAa;EACb,iDAAiD;EACjD,2CAA2C;EAC3C,gBAAgB;EAChB,YAAY;EACZ,mBAAmB;CAAE;AACrB;IACE,4BAA4B;IAC5B,6BAA6B;CAAE;AACjC;IACE,+BAA+B;IAC/B,gCAAgC;CAAE;AACpC;IACE,2CAA2C;CAAE;ACsGjD;EACA,QAAA;EACA,OAAA;EACA,gBAAA;EACA,cAAA;EACA,aAAA;EACA,kBAAA;EACA,mBAAA;CAEA;;ADpGA,oCAAoC", "file": "Menu.vue", "sourcesContent": [".item, .context-menu .search {\n  color: #fff;\n  padding: 4px;\n  border-bottom: 1px solid rgba(69, 103, 255, 0.8);\n  background-color: rgba(110, 136, 255, 0.8);\n  cursor: pointer;\n  width: 100%;\n  position: relative; }\n  .item:first-child, .context-menu .search:first-child {\n    border-top-left-radius: 5px;\n    border-top-right-radius: 5px; }\n  .item:last-child, .context-menu .search:last-child {\n    border-bottom-left-radius: 5px;\n    border-bottom-right-radius: 5px; }\n  .item:hover, .context-menu .search:hover {\n    background-color: rgba(130, 153, 255, 0.8); }\n\n.context-menu {\n  left: 0;\n  top: 0;\n  position: fixed;\n  padding: 10px;\n  width: 120px;\n  margin-top: -20px;\n  margin-left: -60px; }\n\n/*# sourceMappingURL=Menu.vue.map */", null] }, media: undefined });
    };
    /* scoped */
    const __vue_scope_id__$2 = "data-v-8dfbff8c";
    /* module identifier */
    const __vue_module_identifier__$2 = undefined;
    /* functional template */
    const __vue_is_functional_template__$2 = false;
    /* component normalizer */
    function __vue_normalize__$2(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
      const component = (typeof script === 'function' ? script.options : script) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "/media/ni55an/1902898F7AF8DF70102/Workflow/retejs/context-menu-plugin/src/Menu.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
      }

      component._scopeId = scope;

      {
        let hook;
        if (style) {
          hook = function (context) {
            style.call(this, createInjector(context));
          };
        }

        if (hook !== undefined) {
          if (component.functional) {
            // register for functional component in vue file
            const originalRender = component.render;
            component.render = function renderWithStyleInjection(h, context) {
              hook.call(context);
              return originalRender(h, context);
            };
          } else {
            // inject component registration as beforeCreate hook
            const existing = component.beforeCreate;
            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
        }
      }

      return component;
    }
    /* style inject */
    function __vue_create_injector__$2() {
      const head = document.head || document.getElementsByTagName('head')[0];
      const styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
      const isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

      return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

        const group = isOldIE ? css.media || 'default' : id;
        const style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
          let code = css.source;
          let index = style.ids.length;

          style.ids.push(id);

          if (isOldIE) {
            style.element = style.element || document.querySelector('style[data-group=' + group + ']');
          }

          if (!style.element) {
            const el = style.element = document.createElement('style');
            el.type = 'text/css';

            if (css.media) el.setAttribute('media', css.media);
            if (isOldIE) {
              el.setAttribute('data-group', group);
              el.setAttribute('data-next-index', '0');
            }

            head.appendChild(el);
          }

          if (isOldIE) {
            index = parseInt(style.element.getAttribute('data-next-index'));
            style.element.setAttribute('data-next-index', index + 1);
          }

          if (style.element.styleSheet) {
            style.parts.push(code);
            style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
          } else {
            const textNode = document.createTextNode(code);
            const nodes = style.element.childNodes;
            if (nodes[index]) style.element.removeChild(nodes[index]);
            if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
          }
        }
      };
    }
    /* style inject SSR */

    var Menu = __vue_normalize__$2({ render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 }, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, __vue_create_injector__$2, undefined);

    class Menu$1 {

        constructor(editor, props) {
            const el = document.createElement('div');

            editor.view.container.appendChild(el);

            this.menu = new Vue({
                render: h => {
                    return h(Menu, { props });
                }
            }).$mount(el);
        }

        addItem(...args) {
            this.menu.$emit('additem', ...args);
        }

        show(...args) {
            this.menu.$emit('show', ...args);
        }

        hide() {
            this.menu.$emit('hide');
        }
    }

    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

    function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

    function configureNodeItems(menu, editor) {
        menu.addItem('Delete', ({ node }) => {
            return editor.removeNode(node);
        });
        menu.addItem('Clone', async args => {
            const _args$node = args.node,
                  { name, position: [x, y] } = _args$node,
                  params = _objectWithoutProperties(_args$node, ['name', 'position']);
            const component = editor.components.get(name);

            editor.addNode((await createNode(component, _extends({}, params, { x: x + 10, y: y + 10 }))));
        });
    }

    function configureMainItems(menu, editor, { items, allocate, rename }) {
        const mouse = { x: 0, y: 0 };

        editor.on('mousemove', ({ x, y }) => {
            mouse.x = x;
            mouse.y = y;
        });

        editor.on('componentregister', component => {
            const path = allocate(component);

            if (Array.isArray(path)) // add to the menu if path is array
                menu.addItem(rename(component), async () => {
                    editor.addNode((await createNode(component, mouse)));
                }, path);
        });

        traverse(items, (name, func, path) => {
            return menu.addItem(name, func, path);
        });
    }

    function install(editor, {
        searchBar = true,
        delay = 1000,
        items = {},
        allocate = () => {
            return [];
        },
        rename = component => {
            return component.name;
        }
    }) {
        editor.bind('hidecontextmenu');

        const menu = new Menu$1(editor, { searchBar, delay });
        const nodeMenu = new Menu$1(editor, { searchBar: false, delay });

        configureNodeItems(nodeMenu, editor);
        configureMainItems(menu, editor, { items, allocate, rename });

        editor.on('hidecontextmenu', () => {
            menu.hide();
            nodeMenu.hide();
        });

        editor.on('click contextmenu', () => {
            editor.trigger('hidecontextmenu');
        });

        editor.on('contextmenu', ({ e, node }) => {
            e.preventDefault();
            e.stopPropagation();

            const [x, y] = [e.clientX, e.clientY];

            if (node) {
                nodeMenu.show(x, y, { node });
            } else {
                menu.show(x, y);
            }
        });
    }

    var index = {
        name: 'context-menu',
        install
    };

    return index;

})));
//# sourceMappingURL=context-menu-plugin.debug.js.map
