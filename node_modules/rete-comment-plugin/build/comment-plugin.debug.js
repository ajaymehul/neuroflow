/*!
* rete-comment-plugin v0.2.1 
* (c) 2019 Vitaliy Stoliarov 
* Released under the ISC license.
*/
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.CommentPlugin = factory());
}(this, (function () { 'use strict';

    function ___$insertStyle(css) {
      if (!css) {
        return;
      }
      if (typeof window === 'undefined') {
        return;
      }

      var style = document.createElement('style');

      style.setAttribute('type', 'text/css');
      style.innerHTML = css;
      document.head.appendChild(style);

      return css;
    }

    ___$insertStyle(".inline-comment, .frame-comment {\n  color: black;\n  padding: 12px;\n  font-size: 140%;\n  color: white;\n  position: absolute;\n  cursor: move;\n  border-radius: 16px; }\n  .inline-comment:focus, .frame-comment:focus {\n    outline: none;\n    border-color: #ffd92c; }\n\n.inline-comment {\n  z-index: 4;\n  background: #aec4ff;\n  border: 3px solid #aec4ff; }\n\n.frame-comment {\n  z-index: -10;\n  background: rgba(15, 80, 255, 0.2);\n  border: 6px solid transparent; }\n");

    class Draggable {

        constructor(el, onStart = () => {}, onTranslate = () => {}, onDrag = () => {}) {
            this.mouseStart = null;

            this.el = el;
            this.onStart = onStart;
            this.onTranslate = onTranslate;
            this.onDrag = onDrag;

            this.initEvents(el);
        }

        initEvents(el) {
            el.addEventListener('mousedown', this.down.bind(this));
            window.addEventListener('mousemove', this.move.bind(this));
            window.addEventListener('mouseup', this.up.bind(this));

            el.addEventListener('touchstart', this.down.bind(this));
            window.addEventListener('touchmove', this.move.bind(this), {
                passive: false
            });
            window.addEventListener('touchend', this.up.bind(this));
        }

        getCoords(e) {
            const props = e.touches ? e.touches[0] : e;

            return [props.pageX, props.pageY];
        }

        down(e) {
            e.stopPropagation();
            this.mouseStart = this.getCoords(e);

            this.onStart();
        }

        move(e) {
            if (!this.mouseStart) return;
            e.preventDefault();
            e.stopPropagation();

            let [x, y] = this.getCoords(e);
            let delta = [x - this.mouseStart[0], y - this.mouseStart[1]];
            let zoom = this.el.getBoundingClientRect().width / this.el.offsetWidth;

            this.onTranslate(delta[0] / zoom, delta[1] / zoom);
        }

        up() {
            if (this.mouseStart) {
                this.onDrag();
            }

            this.mouseStart = null;
        }
    }

    class Comment {
        constructor(text, editor) {
            this.editor = editor;
            this.text = text;
            this.scale = 1;
            this.x = 0;
            this.y = 0;
            this.dragPosition = [0, 0];
            this.links = [];

            this.el = document.createElement('div');
            this.el.tabIndex = 1;
            this.el.addEventListener('contextmenu', this.onClick.bind(this));
            this.el.addEventListener('focus', this.onFocus.bind(this));
            this.el.addEventListener('blur', this.onBlur.bind(this));

            new Draggable(this.el, () => {
                return this.onStart();
            }, (dx, dy) => {
                return this.onTranslate(dx, dy);
            });
            this.update();
        }

        linkTo(ids) {
            this.links = ids || [];
        }

        linkedTo(node) {
            return this.links.includes(node.id);
        }

        k() {
            return 1;
        }

        onClick(e) {
            e.preventDefault();
            e.stopPropagation();

            let newText = prompt('Comment', this.text);

            if (newText) {
                this.text = newText;
                this.update();
            }
        }

        onFocus() {
            this.scale = Math.max(1, 1 / this.k());
            this.update();
            this.editor.trigger('commentselected', this);
        }

        focused() {
            return document.activeElement === this.el;
        }

        onBlur() {
            this.scale = 1;
            this.update();
        }

        blur() {
            this.el.blur();
        }

        onStart() {
            this.dragPosition = [this.x, this.y];
        }

        onTranslate(dx, dy) {
            const [x, y] = this.dragPosition;

            this.x = x + this.scale * dx;
            this.y = y + this.scale * dy;

            this.update();
        }

        update() {
            this.el.innerText = this.text;
            this.el.style.transform = `translate(${this.x}px, ${this.y}px) scale(${this.scale})`;
        }

        toJSON() {
            return {
                text: this.text,
                position: [this.x, this.y],
                links: this.links
            };
        }
    }

    const min = arr => {
        return arr.length === 0 ? 0 : Math.min(...arr);
    };
    const max = arr => {
        return arr.length === 0 ? 0 : Math.max(...arr);
    };

    function intersectRect(r1, r2) {
        return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top);
    }

    function containsRect(r1, r2) {
        return r2.left > r1.left && r2.right < r1.right && r2.top > r1.top && r2.bottom < r1.bottom;
    }

    function nodesBBox(editor, nodes, margin) {
        const left = min(nodes.map(node => {
            return node.position[0];
        })) - margin;
        const top = min(nodes.map(node => {
            return node.position[1];
        })) - margin;
        const right = max(nodes.map(node => {
            return node.position[0] + editor.view.nodes.get(node).el.clientWidth;
        })) + 2 * margin;
        const bottom = max(nodes.map(node => {
            return node.position[1] + editor.view.nodes.get(node).el.clientHeight;
        })) + 2 * margin;

        return {
            left,
            right,
            top,
            bottom,
            width: Math.abs(left - right),
            height: Math.abs(top - bottom),
            getCenter: () => {
                return [(left + right) / 2, (top + bottom) / 2];
            }
        };
    }

    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

    class FrameComment extends Comment {
        constructor(text, editor) {
            super(text, editor);

            this.width = 0;
            this.height = 0;
            this.links = [];
            this.el.className = 'frame-comment';
        }

        linkedNodesView() {
            return this.links.map(id => {
                return this.editor.nodes.find(n => {
                    return n.id === id;
                });
            }).map(node => {
                return this.editor.view.nodes.get(node);
            });
        }

        onStart() {
            super.onStart();
            this.linkedNodesView().map(nodeView => {
                return nodeView.onStart();
            });
        }

        onTranslate(dx, dy) {
            super.onTranslate(dx, dy);
            this.linkedNodesView().map(nodeView => {
                return nodeView.onDrag(dx, dy);
            });
        }

        isContains(node) {
            const commRect = this.el.getBoundingClientRect();
            const view = this.editor.view.nodes.get(node);

            return containsRect(commRect, view.el.getBoundingClientRect());
        }

        update() {
            super.update();

            this.el.style.width = this.width + 'px';
            this.el.style.height = this.height + 'px';
        }

        toJSON() {
            return _extends({}, super.toJSON(), {
                type: 'frame',
                width: this.width,
                height: this.height
            });
        }
    }

    var _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

    class InlineComment extends Comment {
        constructor(text, editor) {
            super(text, editor);

            this.el.className = 'inline-comment';
            this.el.addEventListener('mouseup', this.onDrag.bind(this));
        }

        onDrag() {
            const intersection = this.getIntersectNode();

            this.linkTo(intersection ? [intersection.node.id] : []);
        }

        getIntersectNode() {
            const commRect = this.el.getBoundingClientRect();

            return Array.from(this.editor.view.nodes).map(([node, view]) => {
                return { node, rect: view.el.getBoundingClientRect() };
            }).find(({ rect }) => {
                return intersectRect(commRect, rect);
            });
        }

        offset(dx, dy) {
            this.x += dx;
            this.y += dy;
            this.update();
        }

        toJSON() {
            return _extends$1({}, super.toJSON(), {
                type: 'inline'
            });
        }
    }

    class CommentManager {
        constructor(editor) {
            this.editor = editor;
            this.comments = [];

            editor.on('zoomed', () => {
                this.comments.map(c => {
                    return c.blur.call(c);
                });
            });
        }

        addInlineComment(text, [x, y], links = []) {
            let comment = new InlineComment(text, this.editor);

            comment.k = () => {
                return this.editor.view.area.transform.k;
            };
            comment.x = x;
            comment.y = y;
            comment.linkTo(links);

            this.addComment(comment);
        }

        addFrameComment(text, [x, y], links = [], width = 0, height = 0) {
            let comment = new FrameComment(text, this.editor);

            comment.x = x;
            comment.y = y;
            comment.width = width;
            comment.height = height;
            comment.linkTo(links);

            this.addComment(comment);
        }

        addComment(comment) {
            comment.update();
            this.comments.push(comment);

            this.editor.view.area.appendChild(comment.el);
            this.editor.trigger('commentcreated', comment);
        }

        deleteComment(comment) {
            this.editor.view.area.removeChild(comment.el);
            this.comments.splice(this.comments.indexOf(comment), 1);

            this.editor.trigger('commentremoved', comment);
        }

        deleteFocusedComment() {
            const focused = this.comments.find(c => {
                return c.focused();
            });

            if (focused) this.deleteComment(focused);
        }

        toJSON() {
            return this.comments.map(c => {
                return c.toJSON();
            });
        }

        fromJSON(list) {
            [...this.comments].map(c => {
                return this.deleteComment(c);
            });
            list.map(item => {
                if (item.type === 'frame') {
                    this.addFrameComment(item.text, item.position, item.links, item.width, item.height);
                } else {
                    this.addInlineComment(item.text, item.position, item.links);
                }
            });
        }
    }

    function install(editor, { margin = 30 }) {
        editor.bind('commentselected');
        editor.bind('commentcreated');
        editor.bind('commentremoved');

        const manager = new CommentManager(editor);

        window.addEventListener('keydown', function handleKey(e) {

            if (e.code === 'KeyF' && e.shiftKey) {
                const ids = editor.selected.list.map(node => {
                    return node.id;
                });
                const nodes = ids.map(id => {
                    return editor.nodes.find(n => {
                        return n.id === id;
                    });
                });
                const { left, top, width, height } = nodesBBox(editor, nodes, margin);

                manager.addFrameComment('...', [left, top], ids, width, height);
            } else if (e.code === 'KeyC' && e.shiftKey) {
                const position = Object.values(editor.view.area.mouse);

                manager.addInlineComment('...', position);
            } else if (e.code === 'Delete') {
                manager.deleteFocusedComment();
            }
        });

        editor.on('nodetranslated', ({ node, prev }) => {
            const dx = node.position[0] - prev[0];
            const dy = node.position[1] - prev[1];

            manager.comments.filter(comment => {
                return comment instanceof InlineComment;
            }).filter(comment => {
                return comment.linkedTo(node);
            }).map(comment => {
                return comment.offset(dx, dy);
            });
        });

        editor.on('nodedraged', node => {
            manager.comments.filter(comment => {
                return comment instanceof FrameComment;
            }).filter(comment => {
                const contains = comment.isContains(node);
                const links = comment.links.filter(id => {
                    return id !== node.id;
                });

                comment.links = contains ? [...links, node.id] : links;
            });
        });

        editor.on('commentselected', () => {
            const list = [...editor.selected.list];

            editor.selected.clear();
            list.map(node => {
                return node.update ? node.update() : null;
            });
        });

        editor.on('export', data => {
            data.comments = manager.toJSON();
        });

        editor.on('import', data => {
            manager.fromJSON(data.comments || []);
        });
    }

    var index = {
        install
    };

    return index;

})));
//# sourceMappingURL=comment-plugin.debug.js.map
